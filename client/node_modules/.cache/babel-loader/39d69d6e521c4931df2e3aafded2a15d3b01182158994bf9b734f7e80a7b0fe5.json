{"ast":null,"code":"var passport = require('passport-strategy'),\n  auth_hdr = require('./auth_header'),\n  util = require('util'),\n  url = require('url'),\n  assign = require('./helpers/assign.js');\n\n/**\n * Strategy constructor\n *\n * @param options\n *          secretOrKey: String or buffer containing the secret or PEM-encoded public key. Required unless secretOrKeyProvider is provided.\n *          secretOrKeyProvider: callback in the format secretOrKeyProvider(request, rawJwtToken, done)`,\n *                               which should call done with a secret or PEM-encoded public key\n *                               (asymmetric) for the given undecoded jwt token string and  request\n *                               combination. done has the signature function done(err, secret).\n *                               REQUIRED unless `secretOrKey` is provided.\n *          jwtFromRequest: (REQUIRED) Function that accepts a reqeust as the only parameter and returns the either JWT as a string or null\n *          issuer: If defined issuer will be verified against this value\n *          audience: If defined audience will be verified against this value\n *          algorithms: List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\n *          ignoreExpiration: if true do not validate the expiration of the token.\n *          passReqToCallback: If true the, the verify callback will be called with args (request, jwt_payload, done_callback).\n * @param verify - Verify callback with args (jwt_payload, done_callback) if passReqToCallback is false,\n *                 (request, jwt_payload, done_callback) if true.\n */\nfunction JwtStrategy(options, verify) {\n  passport.Strategy.call(this);\n  this.name = 'jwt';\n  this._secretOrKeyProvider = options.secretOrKeyProvider;\n  if (options.secretOrKey) {\n    if (this._secretOrKeyProvider) {\n      throw new TypeError('JwtStrategy has been given both a secretOrKey and a secretOrKeyProvider');\n    }\n    this._secretOrKeyProvider = function (request, rawJwtToken, done) {\n      done(null, options.secretOrKey);\n    };\n  }\n  if (!this._secretOrKeyProvider) {\n    throw new TypeError('JwtStrategy requires a secret or key');\n  }\n  this._verify = verify;\n  if (!this._verify) {\n    throw new TypeError('JwtStrategy requires a verify callback');\n  }\n  this._jwtFromRequest = options.jwtFromRequest;\n  if (!this._jwtFromRequest) {\n    throw new TypeError('JwtStrategy requires a function to retrieve jwt from requests (see option jwtFromRequest)');\n  }\n  this._passReqToCallback = options.passReqToCallback;\n  var jsonWebTokenOptions = options.jsonWebTokenOptions || {};\n  //for backwards compatibility, still allowing you to pass\n  //audience / issuer / algorithms / ignoreExpiration\n  //on the options.\n  this._verifOpts = assign({}, jsonWebTokenOptions, {\n    audience: options.audience,\n    issuer: options.issuer,\n    algorithms: options.algorithms,\n    ignoreExpiration: !!options.ignoreExpiration\n  });\n}\nutil.inherits(JwtStrategy, passport.Strategy);\n\n/**\n * Allow for injection of JWT Verifier.\n *\n * This improves testability by allowing tests to cleanly isolate failures in the JWT Verification\n * process from failures in the passport related mechanics of authentication.\n *\n * Note that this should only be replaced in tests.\n */\nJwtStrategy.JwtVerifier = require('./verify_jwt');\n\n/**\n * Authenticate request based on JWT obtained from header or post body\n */\nJwtStrategy.prototype.authenticate = function (req, options) {\n  var self = this;\n  var token = self._jwtFromRequest(req);\n  if (!token) {\n    return self.fail(new Error(\"No auth token\"));\n  }\n  this._secretOrKeyProvider(req, token, function (secretOrKeyError, secretOrKey) {\n    if (secretOrKeyError) {\n      self.fail(secretOrKeyError);\n    } else {\n      // Verify the JWT\n      JwtStrategy.JwtVerifier(token, secretOrKey, self._verifOpts, function (jwt_err, payload) {\n        if (jwt_err) {\n          return self.fail(jwt_err);\n        } else {\n          // Pass the parsed token to the user\n          var verified = function (err, user, info) {\n            if (err) {\n              return self.error(err);\n            } else if (!user) {\n              return self.fail(info);\n            } else {\n              return self.success(user, info);\n            }\n          };\n          try {\n            if (self._passReqToCallback) {\n              self._verify(req, payload, verified);\n            } else {\n              self._verify(payload, verified);\n            }\n          } catch (ex) {\n            self.error(ex);\n          }\n        }\n      });\n    }\n  });\n};\n\n/**\n * Export the Jwt Strategy\n */\nmodule.exports = JwtStrategy;","map":{"version":3,"names":["passport","require","auth_hdr","util","url","assign","JwtStrategy","options","verify","Strategy","call","name","_secretOrKeyProvider","secretOrKeyProvider","secretOrKey","TypeError","request","rawJwtToken","done","_verify","_jwtFromRequest","jwtFromRequest","_passReqToCallback","passReqToCallback","jsonWebTokenOptions","_verifOpts","audience","issuer","algorithms","ignoreExpiration","inherits","JwtVerifier","prototype","authenticate","req","self","token","fail","Error","secretOrKeyError","jwt_err","payload","verified","err","user","info","error","success","ex","module","exports"],"sources":["/Users/pamelaklapp/node_modules/passport-jwt/lib/strategy.js"],"sourcesContent":["var passport = require('passport-strategy')\n    , auth_hdr = require('./auth_header')\n    , util = require('util')\n    , url = require('url')\n    , assign = require('./helpers/assign.js');\n\n\n\n/**\n * Strategy constructor\n *\n * @param options\n *          secretOrKey: String or buffer containing the secret or PEM-encoded public key. Required unless secretOrKeyProvider is provided.\n *          secretOrKeyProvider: callback in the format secretOrKeyProvider(request, rawJwtToken, done)`,\n *                               which should call done with a secret or PEM-encoded public key\n *                               (asymmetric) for the given undecoded jwt token string and  request\n *                               combination. done has the signature function done(err, secret).\n *                               REQUIRED unless `secretOrKey` is provided.\n *          jwtFromRequest: (REQUIRED) Function that accepts a reqeust as the only parameter and returns the either JWT as a string or null\n *          issuer: If defined issuer will be verified against this value\n *          audience: If defined audience will be verified against this value\n *          algorithms: List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\n *          ignoreExpiration: if true do not validate the expiration of the token.\n *          passReqToCallback: If true the, the verify callback will be called with args (request, jwt_payload, done_callback).\n * @param verify - Verify callback with args (jwt_payload, done_callback) if passReqToCallback is false,\n *                 (request, jwt_payload, done_callback) if true.\n */\nfunction JwtStrategy(options, verify) {\n\n    passport.Strategy.call(this);\n    this.name = 'jwt';\n\n    this._secretOrKeyProvider = options.secretOrKeyProvider;\n\n    if (options.secretOrKey) {\n        if (this._secretOrKeyProvider) {\n          \tthrow new TypeError('JwtStrategy has been given both a secretOrKey and a secretOrKeyProvider');\n        }\n        this._secretOrKeyProvider = function (request, rawJwtToken, done) {\n            done(null, options.secretOrKey)\n        };\n    }\n\n    if (!this._secretOrKeyProvider) {\n        throw new TypeError('JwtStrategy requires a secret or key');\n    }\n\n    this._verify = verify;\n    if (!this._verify) {\n        throw new TypeError('JwtStrategy requires a verify callback');\n    }\n\n    this._jwtFromRequest = options.jwtFromRequest;\n    if (!this._jwtFromRequest) {\n        throw new TypeError('JwtStrategy requires a function to retrieve jwt from requests (see option jwtFromRequest)');\n    }\n\n    this._passReqToCallback = options.passReqToCallback;\n    var jsonWebTokenOptions = options.jsonWebTokenOptions || {};\n    //for backwards compatibility, still allowing you to pass\n    //audience / issuer / algorithms / ignoreExpiration\n    //on the options.\n    this._verifOpts = assign({}, jsonWebTokenOptions, {\n      audience: options.audience,\n      issuer: options.issuer,\n      algorithms: options.algorithms,\n      ignoreExpiration: !!options.ignoreExpiration\n    });\n\n}\nutil.inherits(JwtStrategy, passport.Strategy);\n\n\n\n/**\n * Allow for injection of JWT Verifier.\n *\n * This improves testability by allowing tests to cleanly isolate failures in the JWT Verification\n * process from failures in the passport related mechanics of authentication.\n *\n * Note that this should only be replaced in tests.\n */\nJwtStrategy.JwtVerifier = require('./verify_jwt');\n\n\n\n/**\n * Authenticate request based on JWT obtained from header or post body\n */\nJwtStrategy.prototype.authenticate = function(req, options) {\n    var self = this;\n\n    var token = self._jwtFromRequest(req);\n\n    if (!token) {\n        return self.fail(new Error(\"No auth token\"));\n    }\n\n    this._secretOrKeyProvider(req, token, function(secretOrKeyError, secretOrKey) {\n        if (secretOrKeyError) {\n            self.fail(secretOrKeyError)\n        } else {\n            // Verify the JWT\n            JwtStrategy.JwtVerifier(token, secretOrKey, self._verifOpts, function(jwt_err, payload) {\n                if (jwt_err) {\n                    return self.fail(jwt_err);\n                } else {\n                    // Pass the parsed token to the user\n                    var verified = function(err, user, info) {\n                        if(err) {\n                            return self.error(err);\n                        } else if (!user) {\n                            return self.fail(info);\n                        } else {\n                            return self.success(user, info);\n                        }\n                    };\n\n                    try {\n                        if (self._passReqToCallback) {\n                            self._verify(req, payload, verified);\n                        } else {\n                            self._verify(payload, verified);\n                        }\n                    } catch(ex) {\n                        self.error(ex);\n                    }\n                }\n            });\n        }\n    });\n};\n\n\n\n/**\n * Export the Jwt Strategy\n */\n module.exports = JwtStrategy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}